# TEA5767 Troubleshooting Analysis (Second Opinion)

## Overview
This document summarizes the issues encountered with a TEA5767 FM tuner module on a Raspberry Pi, including code, wiring, symptoms, and a detailed technical analysis from a second opinion. It is intended for sharing with others for advanced troubleshooting.

---

## Problem Summary
- **Goal:** Use TEA5767 FM module with Raspberry Pi (Python, smbus, I2C)
- **Wiring:**
    - 5V+  → Pi 5V (power only)
    - GND  → Pi GND
    - SDA  → Pi SDA (GPIO 2, pin 3)
    - SCL  → Pi SCL (GPIO 3, pin 5)
    - No other pins (RESET, STBY, EN, etc.) present or connected
- **Symptoms:**
    - `i2cdetect -y 1` shows 0x60 (device present)
    - All Python I2C writes/reads to 0x60 fail with `[Errno 121] Remote I/O error`
    - SDA/SCL idle at 3.0V
    - No audio/static from module
    - Power cycling and re-checking wiring does not resolve

---

## Original Python Test Code
```python
import smbus
import time

TEA5767_ADDR = 0x60
FREQS = [100.1]
SETTLE_S = 0.15

def _calc_bytes(freq_mhz):
    pll = int(4 * ((freq_mhz * 1_000_000) + 225_000) / 32_768)
    data0 = (pll >> 8) & 0x3F
    data1 = pll & 0xFF
    data2 = 0b00110000  # MUTE=0 (unmuted), search=0, stereo=1, soft mute=0
    data3 = 0b00010000
    data4 = 0x00
    return [data0, data1, data2, data3, data4]

bus = smbus.SMBus(1)
for freq in FREQS:
    try:
        bus.write_i2c_block_data(TEA5767_ADDR, 0, _calc_bytes(freq))
    except Exception as exc:
        print(f"{freq} MHz -> WRITE ERROR: {exc}")
        continue
    time.sleep(SETTLE_S)
    try:
        status = bus.read_i2c_block_data(TEA5767_ADDR, 0, 5)
        print(f"{freq} MHz -> OK, status bytes: {status}")
    except Exception as exc:
        print(f"{freq} MHz -> wrote OK, status read failed: {exc}")
```

---

## Second Opinion: Key Findings

### 1. **I2C Write Command Format**
- The TEA5767 does **not** use register-based I2C communication.
- `bus.write_i2c_block_data` sends a register address byte (0) before the data, which the TEA5767 does not expect.
- **Solution:** Use raw I2C block writes (no register address) or the `ioctl` interface.

#### Example Fix (Raw Write):
```python
import fcntl
I2C_SLAVE = 0x0703
TEA5767_ADDR = 0x60

def write_tea5767_raw(bus_num, addr, data):
    with open(f'/dev/i2c-{bus_num}', 'r+b', buffering=0) as f:
        fcntl.ioctl(f, I2C_SLAVE, addr)
        f.write(bytearray(data))

# Usage:
write_tea5767_raw(1, TEA5767_ADDR, _calc_bytes(100.1))
```

### 2. **Mute Bit and PLL**
- Bit 7 of data2 controls mute (1 = mute, 0 = unmute). Your code sets it to 0 (unmuted), which is correct for normal listening.
- Some recommend tuning with mute on, then unmuting after PLL settles.

### 3. **Hardware Checks**
- 3.0V on SDA/SCL is correct for Pi logic.
- Pull-ups may be present on the module or Pi.
- No extra pins (RESET, STBY, EN) to worry about on this module.

### 4. **Diagnostic Steps**
- Try `i2ctransfer` for raw I2C block write/read:
  ```bash
  i2ctransfer -y 1 w5@0x60 0x26 0x9B 0xB0 0x10 0x00
  i2ctransfer -y 1 r5@0x60
  ```
- Lower I2C clock speed in `/boot/config.txt` if using Pi 4 or seeing clock stretching issues:
  ```
  dtparam=i2c_arm_baudrate=10000
  ```

---

## Complete Working Example (Raw I2C Write)
```python
import time
import fcntl
I2C_SLAVE = 0x0703
TEA5767_ADDR = 0x60

def tea5767_tune(freq_mhz):
    pll = int(4 * ((freq_mhz * 1_000_000) + 225_000) / 32_768)
    data = [
        (pll >> 8) & 0x3F,
        pll & 0xFF,
        0xB0,  # MUTE=1 (mute on)
        0x10,
        0x00
    ]
    with open('/dev/i2c-1', 'r+b', buffering=0) as f:
        fcntl.ioctl(f, I2C_SLAVE, TEA5767_ADDR)
        f.write(bytearray(data))
    time.sleep(0.3)
    data[2] = 0x30  # MUTE=0 (unmute)
    with open('/dev/i2c-1', 'r+b', buffering=0) as f:
        fcntl.ioctl(f, I2C_SLAVE, TEA5767_ADDR)
        f.write(bytearray(data))
    print(f"Tuned to {freq_mhz} MHz")

tea5767_tune(100.1)
```

---

## Questions for Reviewers
- Is the raw I2C write approach above correct for the TEA5767?
- Are there any known quirks with certain module clones?
- Is there a required hardware step missing?
- Any other troubleshooting tips?

---

## Additional Info
- Pi model: [fill in]
- TEA5767 module: [fill in, link/photo if possible]
- Can provide photos or more details if needed.
